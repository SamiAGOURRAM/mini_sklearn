digraph "classes" {
rankdir=BT
charset="utf-8"
"mini_sklearn.ensemble.boosting.AdaBoostClassifier" [color="black", fontcolor="black", label=<{AdaBoostClassifier|classes_<br ALIGN="LEFT"/>estimator_errors_ : ndarray<br ALIGN="LEFT"/>estimator_weights_ : ndarray<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>n_classes_<br ALIGN="LEFT"/>n_estimators : int<br ALIGN="LEFT"/>random_state : int<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.ensemble.bagging.BaggingClassifier" [color="black", fontcolor="black", label=<{BaggingClassifier|base_estimator : NoneType<br ALIGN="LEFT"/>bootstrap : bool<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>max_samples : float<br ALIGN="LEFT"/>n_estimators : int<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.ensemble.bagging.BaggingRegressor" [color="black", fontcolor="black", label=<{BaggingRegressor|base_estimator : NoneType<br ALIGN="LEFT"/>bootstrap : bool<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>max_samples : float<br ALIGN="LEFT"/>n_estimators : int<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.tree.decision_tree.BaseDecisionTree" [color="black", fontcolor="black", label=<{BaseDecisionTree|criterion<br ALIGN="LEFT"/>depth : NoneType<br ALIGN="LEFT"/>feature_importances_<br ALIGN="LEFT"/>max_depth : NoneType<br ALIGN="LEFT"/>max_features : NoneType<br ALIGN="LEFT"/>min_samples_split : int<br ALIGN="LEFT"/>|apply(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.base.base.BaseEstimator" [color="black", fontcolor="black", label=<{BaseEstimator|<br ALIGN="LEFT"/>|check_is_fitted(): bool<br ALIGN="LEFT"/><I>fit</I>(X, y)<br ALIGN="LEFT"/><I>score</I>(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.model_selection.__split.BaseKFold" [color="black", fontcolor="black", label=<{BaseKFold|n_splits : int<br ALIGN="LEFT"/>random_state : int<br ALIGN="LEFT"/>shuffle : bool<br ALIGN="LEFT"/>|split(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.naive_bayes.BaseNB" [color="black", fontcolor="black", label=<{BaseNB|<br ALIGN="LEFT"/>|predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.naive_bayes.BernoulliNB" [color="black", fontcolor="black", label=<{BernoulliNB|alpha : float<br ALIGN="LEFT"/>class_count_ : ndarray<br ALIGN="LEFT"/>class_log_prior_<br ALIGN="LEFT"/>classes_ : tuple<br ALIGN="LEFT"/>feature_count_ : ndarray<br ALIGN="LEFT"/>feature_log_prob_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.base.base.ClassifierMixin" [color="black", fontcolor="black", label=<{ClassifierMixin|<br ALIGN="LEFT"/>|<I>predict_log_proba</I>(X)<br ALIGN="LEFT"/><I>predict_proba</I>(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.tree.decision_tree.DecisionTreeClassifier" [color="black", fontcolor="black", label=<{DecisionTreeClassifier|classes_<br ALIGN="LEFT"/>depth<br ALIGN="LEFT"/>n_classes_<br ALIGN="LEFT"/>n_features<br ALIGN="LEFT"/>tree_ : list<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.tree.decision_tree.DecisionTreeRegressor" [color="black", fontcolor="black", label=<{DecisionTreeRegressor|depth<br ALIGN="LEFT"/>n_features<br ALIGN="LEFT"/>tree_ : list<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.naive_bayes.GaussianNB" [color="black", fontcolor="black", label=<{GaussianNB|class_count_ : ndarray<br ALIGN="LEFT"/>class_prior_ : ndarray<br ALIGN="LEFT"/>classes_ : tuple<br ALIGN="LEFT"/>sigma_ : ndarray<br ALIGN="LEFT"/>theta_ : ndarray<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.ensemble.boosting.GradientBoostingClassifier" [color="black", fontcolor="black", label=<{GradientBoostingClassifier|classes_<br ALIGN="LEFT"/>estimators_ : ndarray<br ALIGN="LEFT"/>feature_importances_<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>max_depth : int<br ALIGN="LEFT"/>n_classes_<br ALIGN="LEFT"/>n_estimators : int<br ALIGN="LEFT"/>n_features_<br ALIGN="LEFT"/>random_state : int<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.model_selection.GridSearch.GridSearchCVBase" [color="black", fontcolor="black", label=<{GridSearchCVBase|best_estimator_<br ALIGN="LEFT"/>best_params_<br ALIGN="LEFT"/>cv_results_ : dict<br ALIGN="LEFT"/>estimator<br ALIGN="LEFT"/>param_grid<br ALIGN="LEFT"/>|decision_function(X)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>generate_grid()<br ALIGN="LEFT"/><I>get_cv</I>(y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.model_selection.GridSearch.GridSearchCVClassifier" [color="black", fontcolor="black", label=<{GridSearchCVClassifier|<br ALIGN="LEFT"/>|get_cv(y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.model_selection.GridSearch.GridSearchCVRegressor" [color="black", fontcolor="black", label=<{GridSearchCVRegressor|<br ALIGN="LEFT"/>|get_cv(y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.model_selection.__split.KFold" [color="black", fontcolor="black", label=<{KFold|<br ALIGN="LEFT"/>|split(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.neighbors.KNeighborsClassifier.KNeighborsClassifier" [color="black", fontcolor="black", label=<{KNeighborsClassifier|classes_<br ALIGN="LEFT"/>metric : str<br ALIGN="LEFT"/>n_neighbors : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.preprocessing.encoding.label_encoder.LabelEncoder" [color="black", fontcolor="black", label=<{LabelEncoder|classes_<br ALIGN="LEFT"/>|fit(y)<br ALIGN="LEFT"/>fit_transform(y)<br ALIGN="LEFT"/>transform(y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.linear_model.regression.LinearRegression" [color="black", fontcolor="black", label=<{LinearRegression|coef_<br ALIGN="LEFT"/>intercept_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.linear_model.logistic_regression.LogisticRegression" [color="black", fontcolor="black", label=<{LogisticRegression|coef_<br ALIGN="LEFT"/>intercept_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>get_params(deep)<br ALIGN="LEFT"/>log_likelihood(coef, X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>sigmoid(z)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.preprocessing.transformers.scaler.MinMaxScaler" [color="black", fontcolor="black", label=<{MinMaxScaler|data_max_<br ALIGN="LEFT"/>data_min_<br ALIGN="LEFT"/>data_range_<br ALIGN="LEFT"/>feature_range : tuple<br ALIGN="LEFT"/>scale_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.preprocessing.imputation.missing_indicator.MissingIndicator" [color="black", fontcolor="black", label=<{MissingIndicator|features : str<br ALIGN="LEFT"/>features_<br ALIGN="LEFT"/>missing_values<br ALIGN="LEFT"/>sparse : bool<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>fit_transform(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.utils._encode.MissingValues" [color="black", fontcolor="black", label=<{MissingValues|nan : bool<br ALIGN="LEFT"/>none : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"mini_sklearn.naive_bayes.MultinomialNB" [color="black", fontcolor="black", label=<{MultinomialNB|alpha : float<br ALIGN="LEFT"/>class_count_ : ndarray<br ALIGN="LEFT"/>class_log_prior_<br ALIGN="LEFT"/>classes_ : tuple<br ALIGN="LEFT"/>feature_count_ : ndarray<br ALIGN="LEFT"/>feature_log_prob_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.neural_network.multilayer_perceptron.NeuralNetwork" [color="black", fontcolor="black", label=<{NeuralNetwork|biases : list<br ALIGN="LEFT"/>epochs : int<br ALIGN="LEFT"/>layers<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>weights : list<br ALIGN="LEFT"/>|backward(X, y, activations)<br ALIGN="LEFT"/>fit(X, y)<br ALIGN="LEFT"/>forward(X)<br ALIGN="LEFT"/>one_hot_encode(y, num_classes)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>sigmoid(z)<br ALIGN="LEFT"/>sigmoid_derivative(z)<br ALIGN="LEFT"/>softmax(z)<br ALIGN="LEFT"/>softmax_derivative(output, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.preprocessing.transformers.normalizer.Normalizer" [color="black", fontcolor="black", label=<{Normalizer|norm : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.preprocessing.encoding.one_hot_encoder.OneHotEncoder" [color="black", fontcolor="black", label=<{OneHotEncoder|categories_<br ALIGN="LEFT"/>|fit(X)<br ALIGN="LEFT"/>fit_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.preprocessing.encoding.ordinal_encoder.OrdinalEncoder" [color="black", fontcolor="black", label=<{OrdinalEncoder|categories_<br ALIGN="LEFT"/>|fit(X)<br ALIGN="LEFT"/>fit_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.decomposition.pca.PCA" [color="black", fontcolor="black", label=<{PCA|components_<br ALIGN="LEFT"/>explained_variance_<br ALIGN="LEFT"/>explained_variance_ratio_<br ALIGN="LEFT"/>mean_ : ndarray<br ALIGN="LEFT"/>n_components : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>inverse_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.feature_selection.RFE.RFE" [color="black", fontcolor="black", label=<{RFE|estimator<br ALIGN="LEFT"/>estimator_<br ALIGN="LEFT"/>ranking_ : ndarray<br ALIGN="LEFT"/>support_ : ndarray<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.ensemble.random_forest.RandomForestClassifier" [color="black", fontcolor="black", label=<{RandomForestClassifier|bootstrap : bool<br ALIGN="LEFT"/>classes_<br ALIGN="LEFT"/>criterion : str<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>feature_importances_<br ALIGN="LEFT"/>max_depth : NoneType<br ALIGN="LEFT"/>max_features : str<br ALIGN="LEFT"/>min_samples_split : int<br ALIGN="LEFT"/>n_classes_<br ALIGN="LEFT"/>n_estimators : int<br ALIGN="LEFT"/>n_features_<br ALIGN="LEFT"/>n_samples_<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.ensemble.random_forest.RandomForestRegressor" [color="black", fontcolor="black", label=<{RandomForestRegressor|bootstrap : bool<br ALIGN="LEFT"/>criterion : str<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>feature_importances_<br ALIGN="LEFT"/>max_depth : NoneType<br ALIGN="LEFT"/>max_features : str<br ALIGN="LEFT"/>min_samples_split : int<br ALIGN="LEFT"/>n_estimators : int<br ALIGN="LEFT"/>n_features_<br ALIGN="LEFT"/>n_samples_<br ALIGN="LEFT"/>random_state : NoneType<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.base.base.RegressorMixin" [color="black", fontcolor="black", label=<{RegressorMixin|<br ALIGN="LEFT"/>|score(X, y, sample_weight)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.feature_selection.select_from_model.SelectFromModel" [color="black", fontcolor="black", label=<{SelectFromModel|estimator<br ALIGN="LEFT"/>estimator_<br ALIGN="LEFT"/>importances_ : ndarray<br ALIGN="LEFT"/>threshold_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.preprocessing.imputation.simple_imputer.SimpleImputer" [color="black", fontcolor="black", label=<{SimpleImputer|fill_value : NoneType<br ALIGN="LEFT"/>statistics_ : ndarray<br ALIGN="LEFT"/>strategy : str<br ALIGN="LEFT"/>|fit(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.ensemble.stacking.StackingClassifier" [color="black", fontcolor="black", label=<{StackingClassifier|estimators<br ALIGN="LEFT"/>estimators_ : list<br ALIGN="LEFT"/>final_estimator<br ALIGN="LEFT"/>final_estimator_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.ensemble.stacking.StackingRegressor" [color="black", fontcolor="black", label=<{StackingRegressor|estimators<br ALIGN="LEFT"/>estimators_<br ALIGN="LEFT"/>final_estimator<br ALIGN="LEFT"/>final_estimator_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.preprocessing.transformers.scaler.StandardScaler" [color="black", fontcolor="black", label=<{StandardScaler|mean_ : ndarray<br ALIGN="LEFT"/>scale_ : ndarray<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.model_selection.__split.StratifiedKFold" [color="black", fontcolor="black", label=<{StratifiedKFold|<br ALIGN="LEFT"/>|split(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.base.base.TransformerMixin" [color="black", fontcolor="black", label=<{TransformerMixin|<br ALIGN="LEFT"/>|fit_transform(X, y)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.tree.decision_tree.TreeNode" [color="black", fontcolor="black", label=<{TreeNode|feature : NoneType<br ALIGN="LEFT"/>impurity : NoneType, ndarray<br ALIGN="LEFT"/>left_child : int<br ALIGN="LEFT"/>n_node : NoneType<br ALIGN="LEFT"/>right_child : int<br ALIGN="LEFT"/>threshold : NoneType<br ALIGN="LEFT"/>value : NoneType, ndarray<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"mini_sklearn.feature_selection.variance_threshold.VarianceThreshold" [color="black", fontcolor="black", label=<{VarianceThreshold|threshold : int<br ALIGN="LEFT"/>variances_ : ndarray<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.ensemble.voting.VotingClassifier" [color="black", fontcolor="black", label=<{VotingClassifier|classes_<br ALIGN="LEFT"/>estimators<br ALIGN="LEFT"/>estimators_<br ALIGN="LEFT"/>voting : str<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.ensemble.voting.VotingRegressor" [color="black", fontcolor="black", label=<{VotingRegressor|estimators<br ALIGN="LEFT"/>estimators_<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"mini_sklearn.model_selection.GridSearch.GridSearchCVClassifier" -> "mini_sklearn.model_selection.GridSearch.GridSearchCVBase" [arrowhead="empty", arrowtail="none"];
"mini_sklearn.model_selection.GridSearch.GridSearchCVRegressor" -> "mini_sklearn.model_selection.GridSearch.GridSearchCVBase" [arrowhead="empty", arrowtail="none"];
"mini_sklearn.model_selection.__split.KFold" -> "mini_sklearn.model_selection.__split.BaseKFold" [arrowhead="empty", arrowtail="none"];
"mini_sklearn.model_selection.__split.StratifiedKFold" -> "mini_sklearn.model_selection.__split.BaseKFold" [arrowhead="empty", arrowtail="none"];
"mini_sklearn.naive_bayes.BernoulliNB" -> "mini_sklearn.naive_bayes.BaseNB" [arrowhead="empty", arrowtail="none"];
"mini_sklearn.naive_bayes.GaussianNB" -> "mini_sklearn.naive_bayes.BaseNB" [arrowhead="empty", arrowtail="none"];
"mini_sklearn.naive_bayes.MultinomialNB" -> "mini_sklearn.naive_bayes.BaseNB" [arrowhead="empty", arrowtail="none"];
"mini_sklearn.tree.decision_tree.DecisionTreeClassifier" -> "mini_sklearn.tree.decision_tree.BaseDecisionTree" [arrowhead="empty", arrowtail="none"];
"mini_sklearn.tree.decision_tree.DecisionTreeRegressor" -> "mini_sklearn.tree.decision_tree.BaseDecisionTree" [arrowhead="empty", arrowtail="none"];
}
